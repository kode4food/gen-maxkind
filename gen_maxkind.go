package main

import (
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
)

const (
	packageName   = "maxkind"
	outputFile    = "maxkind/value_gen.go"
	maxKindSearch = 1024
	fileMode      = 0644
	dirMode       = 0755
)

const codeTemplate = `// Code generated by gen_maxkind.go; DO NOT EDIT.
package %s

import "reflect"

// Value is the largest reflect.Kind value for this Go version.
const Value = reflect.%s
`

var alphaPrefix = regexp.MustCompile(`^([a-zA-Z]+)`)

func main() {
	if err := generateMaxKindFile(); err != nil {
		log.Fatalf("Failed to generate max kind file: %v", err)
	}
}

func generateMaxKindFile() error {
	maxKindName, err := findMaxKind()
	if err != nil {
		return err
	}

	src := fmt.Sprintf(codeTemplate, packageName, maxKindName)

	formatted, err := format.Source([]byte(src))
	if err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Dir(outputFile), dirMode); err != nil {
		return err
	}

	if err := os.WriteFile(outputFile, formatted, fileMode); err != nil {
		return err
	}

	return nil
}

func findMaxKind() (string, error) {
	invalidPrefix, err := getInvalidKindPrefix()
	if err != nil {
		return "", err
	}

	var maxName string
	for i := range maxKindSearch {
		kind := reflect.Kind(i)
		kindStr := kind.String()
		if strings.HasPrefix(kindStr, invalidPrefix) {
			continue
		}
		maxName = kindStr
	}

	if maxName == "" {
		return "", fmt.Errorf("no valid reflect.Kind values found")
	}

	return stringToConstantName(maxName), nil
}

func getInvalidKindPrefix() (string, error) {
	var invalidPrefixes []string

	// Check several invalid kinds, e.g., "kind1025", "kind1026", etc.
	for i := range 10 {
		invalidKind := reflect.Kind(maxKindSearch + i).String()
		prefix := getNonNumericPrefix(invalidKind)

		if prefix != "" {
			invalidPrefixes = append(invalidPrefixes, prefix)
		}
	}

	if len(invalidPrefixes) == 0 {
		return "", fmt.Errorf("no non-numeric prefixes found in invalid kinds")
	}

	if commonPrefix := findCommonPrefix(invalidPrefixes); commonPrefix != "" {
		return commonPrefix, nil
	}
	return "", fmt.Errorf(
		"no common prefix found among invalid kinds: %v", invalidPrefixes,
	)
}

func getNonNumericPrefix(s string) string {
	match := alphaPrefix.FindStringSubmatch(s)
	if len(match) > 1 {
		return match[1]
	}
	return s
}

func findCommonPrefix(strs []string) string {
	switch len(strs) {
	case 0:
		return ""
	case 1:
		return strs[0]
	default:
		prefix := strs[0]
		for _, s := range strs[1:] {
			prefix = commonPrefix(prefix, s)
			if prefix == "" {
				break
			}
		}
		return prefix
	}
}

func commonPrefix(s1, s2 string) string {
	minLen := min(len(s2), len(s1))
	for i := range minLen {
		if s1[i] != s2[i] {
			return s1[:i]
		}
	}
	return s1[:minLen]
}

func stringToConstantName(s string) string {
	if len(s) == 0 {
		return s
	}

	// Handle dotted names like "unsafe.Pointer" -> "UnsafePointer"
	if strings.Contains(s, ".") {
		parts := strings.Split(s, ".")
		var result strings.Builder
		for _, part := range parts {
			if len(part) > 0 {
				result.WriteString(strings.ToUpper(part[:1]) + part[1:])
			}
		}
		return result.String()
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
